//=================================================================================================
// Copyright (c) 2012, Johannes Meyer, TU Darmstadt
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Flight Systems and Automatic Control group,
//       TU Darmstadt, nor the names of its contributors may be used to
//       endorse or promote products derived from this software without
//       specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//=================================================================================================

#include <introspection/message.h>
#include <rosmatlab/conversion.h>
#include <rosmatlab/options.h>
#include "introspection/@package@/package.h"
#include "mex.h"

#include <@package@/@msg@.h>

using namespace rosmatlab;
typedef ::@package@::@msg@ MessageType;

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
  PackagePtr package = cpp_introspection::@package@::Instance();
  MessagePtr message = messageByDataType("@package@/@msg@");

  if (!message) {
    mexPrintf("[rosmatlab] Message @package@/@msg@ is unknown.\n");
    return;
  }

  // parse inputs
  mxArray *repeat = 0;
  bool want_array = false;
  for(int i = 0; i < nrhs; i++) {
    if (mxIsChar(prhs[i])) {
      std::string option = Options::getString(prhs[i]);
      if (option == "expand") want_array = true;
      if (option == "definition") {
        plhs[0] = mxCreateString(message->getDefinition());
        return;
      }
      if (option == "md5sum") {
        plhs[0] = mxCreateString(message->getMD5Sum());
        return;
      }
      continue;
    }

    if (mxIsNumeric(prhs[i]) && mxGetNumberOfElements(prhs[i]) == 1 && !repeat) {
      repeat = mxDuplicateArray(prhs[i]);
      continue;
    }

    if (mxIsStruct(prhs[i]) || mxIsDouble(prhs[i])) {
      std::size_t size = mxIsDouble(prhs[i]) ? (mxGetM(prhs[i]) > 1 ? mxGetN(prhs[i]) : 1) : mxGetNumberOfElements(prhs[i]);
      for(std::size_t j = 0; j < size; j++) {
        MessagePtr m = Conversion(message).fromMatlab(prhs[i], j);
//        std::cout << "Constructed a " << m->getDataType() << " message: " << *boost::shared_static_cast<MessageType const>(m->getConstInstance()) << std::endl;
        Conversion conversion(m);
        plhs[0] = want_array ? conversion.toDoubleMatrix(plhs[0], j) : conversion.toStruct(plhs[0], j);
      }
    }
  }

  if (!plhs[0]) {
    MessagePtr m = message->introspect(message->createInstance());
//    std::cout << "Constructed a new " << m->getDataType() << " message: " << *boost::shared_static_cast<MessageType const>(m->getConstInstance()) << std::endl;
    Conversion conversion(m);
    plhs[0] = want_array ? conversion.toDoubleMatrix() : conversion.toStruct();
  }

  if (repeat) {
    mxArray *repmat_rhs[3] = { plhs[0], mxCreateDoubleScalar(1), repeat };
    mexCallMATLAB(nlhs, plhs, 3, repmat_rhs, "repmat");
    mxDestroyArray(repmat_rhs[0]);
    mxDestroyArray(repmat_rhs[1]);
    mxDestroyArray(repmat_rhs[2]);
  }

  return;
}
