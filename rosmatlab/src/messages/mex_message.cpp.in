//=================================================================================================
// Copyright (c) 2012, Johannes Meyer, TU Darmstadt
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Flight Systems and Automatic Control group,
//       TU Darmstadt, nor the names of its contributors may be used to
//       endorse or promote products derived from this software without
//       specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//=================================================================================================

#include <introspection/message.h>
#include <rosmatlab/conversion.h>
#include "introspection/@package@/package.h"
#include "mex.h"

using namespace rosmatlab;

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
  PackagePtr package = cpp_introspection::@package@::Instance();
  MessagePtr message = messageByDataType("@package@/@msg@");

  if (!message) {
    mexPrintf("[rosmatlab] Message @package@/@msg@ is unknown.\n");
    return;
  }

  // parse inputs
  Array repmat_rhs[3] = { 0, 0, 0 };
  bool want_array = false;
  for(int i = 0; i < nrhs; i++) {
    if (mxIsChar(prhs[i])) {
      std::string option(mxGetChars(prhs[i]), mxGetChars(prhs[i]) + mxGetNumberOfElements(prhs[i]));
      if (option == "expand") want_array = true;
      if (option == "definition") {
        plhs[0] = mxCreateString(message->getDefinition());
        return;
      }
      if (option == "md5sum") {
        plhs[0] = mxCreateString(message->getMD5Sum());
        return;
      }
    }

    if (mxIsNumeric(prhs[i]) && !repmat_rhs[1]) {
      repmat_rhs[1] = mxDuplicateArray(prhs[i]);
    }
  }

  VoidPtr instance = message->createInstance();
  Conversion conversion(message->introspect(instance.get()));
  plhs[0] = want_array ? conversion.toDoubleMatrix() : conversion.toStruct();

  if (repmat_rhs[1]) {
    repmat_rhs[0] = plhs[0];
    repmat_rhs[2] = mxCreateDoubleScalar(1);
    mexCallMATLAB(nlhs, plhs, 3, repmat_rhs, "repmat");
  }

  mxDestroyArray(repmat_rhs[0]);
  mxDestroyArray(repmat_rhs[1]);
  mxDestroyArray(repmat_rhs[2]);

  return;
}
